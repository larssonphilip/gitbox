Search is basically a filter of commits by a search tokens.

1. Простой git log -p с опциями форматирования как в GBHistoryTask позволит получить сразу кучу пирожков:
- поиск по метаданным коммита: автор, sha, дата
- поиск по именам файлов (включая папки)
- поиск по измененному тексту - можно распарсить дифф и искать в добавленных и удаленных строках. Это ОЧЕНЬ ценно, когда ты знаешь какой кусок кода тебя волнует и нужно найти кто и как его менял и из какого файла он изначально взялся и где использовался.

2. Не должно быть никакого перманентного поискового индекса: искать нужно на лету, всякий раз по-новой загружая всю историю. Так будет гораздо проще тестировать и исправлять миллион багов. Когда качество поиска будет удовлетворительным, можно будет подумать каким хитрым способ сделать его быстрее, но не раньше.

3. UI такой: 
+ по cmd+F всплывает поисковая строка.
+ никаких галочек, scope selectors и кнопок Cancel или Find: только строка, которая ищет везде и по всему.
+ если жмем Esc - поле очищается и уплывает обратно. Обычные коммиты высвечиваются.
? если поле теряет фокус когда пустое, то тоже уплывает обратно.
- если поле пустое, рисуем обычные коммиты и стейдж.
- при вводе текста, делаем задержку, после которой запускаем новый поиск.
- если ввели еще, а задержка не прошла, перезапускаем таймер. (performSelector:...afterDelay тут как раз к месту)
- найденные коммиты - новый инстансы GBCommit.
- в коммитах желтым маркером подсвечиваются найденные строки.
- при выборе коммита - загружаются новые инстансы GBChange.
- в списке изменений имена файлов подсвечиваем желтым маркером те куски, которые найдены.
- если кусок имени файла не подсвечен, но найден текст внутри файла, то все имя файла подсвечено.
- в заголовке коммита подсвечены найденные куски.
- в полном тексте коммита подсвечены найденные куски.

3.5. UI architecture:

  - GBRepositoryController:
    - search:(id)sender
    - cancelSearch:(id)sender
    - setSearchString:
    - GBRepositoryControllerSearchDidStart notification
    - GBRepositoryControllerSearchDidEnd notification
    - GBRepositoryControllerSearchResultsDidChange notification


4. Синтаксис поиска: 
- набор поисковых слов [^\s]+ через пробел ищется по правилу AND
- нужно уметь понимать текст в кавычках ("some text"), включая escape-последовательности: \"
- если токен распарсен без кавычек - его искать без учета регистра, если в кавычках - то ровно так, как введен.
- если кавычка не закрыта, считаем, что она закрыта в конце всей строки.

5. Технология поиска:
- так как хочется искать внутри патча, простой git rev-list -grep отпадает начисто.
- так как NSScanner любит строки, а строки любят валидный UTF-8, то потоковый парсинг из пайпа тоже отпадает. В принципе, с кучей хаков можно наваять, но затраты не будут оправданы небольшим приростом скорости. Дизайнер, помни: главное - не абсолютная скорость интерфейса, а ощущение контроля над ситуацией и постоянный фидбек.
- с учетом вышесказанного, нужно грузить историю регулярными запросами все дальше и дальше в историю до тех пор, пока не упремся в конец или пока поиск не будет отменен или перезапущен.

Поскольку история не линейная, нужно позаботиться о том, чтобы не потерять коммиты и не включить их дважды. Поэтому:
- нужно проверить с какими опциями заставить гит найти все-все коммиты после какого-то известного. Возможно, это получится только по дате (--after или как там этот флаг называется).
- при парсинге истории всегда проверять, нет ли этого коммита уже в списке и игнорировать его, если есть.

Разные замечания:
- в git-log есть опция -S для фильтрации только по тем патчам, где есть строка. Нам, скорее всего, совсем никак не подойдет, т.к. нужно искать не только в патче и без учета регистра.
- git-log по умолчанию исключает какие-то uninteresting commits: опция --boundary вроде как это поведение выключает. Нужно проверить в мануале.

После того, как поиск в принципе работает от А до Я, можно сделать несколько оптимизаций (в порядке приоритета):

1. Поскольку ты можешь пробовать разные запросы, то первые, скажем, 1000 коммитов имеет смысл закешировать (пока не отменишь поиск совсем). Все остальные коммиты будут сразу выкидываться при фильтрации и не занимать память, а первые 1000 сразу показывать отфильтрованный результат.

2. Когда начинаешь поиск и еще не загрузил первую 1000 коммитов с патчами, имеет смысл сразу фильтровать те, которые уже загружены (хоть и без патчей). 

3. Может быть, потом окажется что имеет смысл обычные непоисковые коммиты грузить с патчами сразу. Особенно, если сделать автоматическую подгрузку по мере скроллинга, можно будет для начала грузить не 1000, а всего 100 коммитов. Хотя все равно нужно иметь в виду, что патчи могут быть очень большими (скажем, добавили текстовый файл на 10 мегабайт).

Но, опять-таки, это все разного рода трюки, о которых нужно задумываться лишь после окончания базовой рабочей версии. И они довольно неоднозначны в плане расхода ресурсов.
